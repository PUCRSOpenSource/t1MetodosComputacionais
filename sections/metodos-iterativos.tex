\section{Métodos Iterativos}
\label{sec:metodos-iterativos}

	Um \textbf{método iterativo} é um procedimento matemático que gera uma
	sequência de aproximações, e quando esta sequência é convergente esta
	aproximação pode ser aceita como a solução para uma classe de problemas. Um
	método iterativo é considerado \textbf{convergente} se a sequência de
	valores geradas converge para uma dada aproximação inicial.

	Para uma definição mais teórica, o seguinte autor define:

	\begin{quotation}

		``Um método iterativo consiste em repetir uma determinada operação um
		certo número de vezes até que nos seja fornecida uma aproximação, que
		satisfaça as condições do problema e, para tal, a sequência de valores
		deve ser convergente.''\cite{batista2014metodos}

	\end{quotation}

	Nos problemas do tipo encontre a raíz da equação, um método iterativo usa
	uma suposição inicial para gerar sucessivas aproximações à uma solução. Em
	Contraste, \textbf{métodos diretos} tentam resolver o problema em uma
	sequência \emph{finita} de operações.

	Um método iterativo é formado por quatro partes:~\cite{claudio2000calculo}

	\begin{enumerate}[a)]

		\item Estimativa inicial: uma ou mais aproximações para a raiz desejada.

		\item Atualização: uma fórmula que atualize a solução aproximada.

		\item Critério de parada: uma forma de estabelecer quando parar o
			processo iterativo em qualquer caso.

		\item Estimador de exatidão: está associado ao critério de parada e
			provê uma estimativa do erro cometido.

	\end{enumerate}

	Nas próximas seções serão apresentadas as constantes utilizando métodos
	iterativos, bem como a análise de convergência. A análise de convergência é
	obtida calculando a diferença entre a constate e o valor obtido na iteração,
	ou seja, usamos a medida de erro absoluto. Os algoritmos utilizados seguem o
	mesmo formato, no sentido de que sempre que o executamos é informado o
	número máximo de iterações e o erro tolerável. Quando uma das condições é
	satisfeita, assim começamos a análise dos resultados obtidos.

	Os algoritmos utilizados para a extração dos resultados foram escritos e
	executados no ambiente matemático \emph{octave}, pois o grupo possui uma
	prévia familiaridade com a ferramenta. 
	
	\subsection{Número de Ouro}
		
		O número de ouro, também denotada pela letra grega $\phi$ e é obitdo a
		partir da raiz positiva da Equação~\ref{eq:phi}

		\begin{equation}
			x^2-x-1
		\label{eq:phi}
		\end{equation}

		Existem algums algoritmos para realizar a aproximação neste artigo,
		sendo duas destas formas  abordadas. A primeira utilizando frações
		continuas e o segundo calculando as raizaes da equação utiizando método
		de newton.

		\subsubsection{Frações Continuadas}

			Frações conitinuadas são formas de representar números reais de tal
			forma que a expressão básica tem o seguinte formato:

			\begin{equation}
			\label{eq:phi-frac}
				a_0 + \frac{b_0}{a_1 + \frac{b_1}{a_n + \dots}}
			\end{equation}

			Para calcular o $\phi$ devemos substituir \emph{a} e \emph{b} por
			\emph{1} na Fração~\ref{eq:phi}. A Tabela~\ref{table:phi-frac} foi
			obtida utlizando o método de frações continuadas de forma que o
			número máximo de iterações é 50 e o erro aceitável é $10^{-15}$. Onde
			podemos observar que a partir da iteração \emph{39} o erro foi
			menor do que a tolerancia.

			\input{./tables/phi.tex}


			\begin{figure}[H]
				\centering
				\includegraphics[width=100mm]{golden_frac.png}
				\caption{Convergência do número de ouro pelo método de frações continuadas}
				\label{golden_frac}
			\end{figure}


			Os valores foram obtidos a partir do algoritmo abaixo:

			\begin{lstlisting}

			function phi_frac(iteration, err)
			phi = (1 + sqrt(5))/2
			aux = 1
			x(1,1) = 1
			x(2,1) = aux
			x(3,1) = phi
			x(4,1) = abs(phi - aux)

			i = 2
			while xor(i <= iteration,  err > x(4, i-1))
				aux = double(1 + 1/aux)
				x(1,i) = i
				x(2,i) = aux
				x(3,i) = phi
				x(4,i) = abs(phi - aux)
				i++
			end

			end

			\end{lstlisting}

		\subsubsection{Método de Newton}

			A ideia do método de Newton é a partir de um valor inicial
			arbitrário, então a função é aproximada por sua reta tangente. O $x$
			que intercepta a reta e a função é computado, e ele será uma melhor
			aproximação que o chute inicial. O método, então, pode ser iterado.

			Analizando novamente o número de ouro, mas com o método de newton,
			um número muito menor de iterações é observado.

			\input{./tables/phi-newton.tex}

			Isso pode ser observado no gráfico abaixo.

			\begin{figure}[H]
				\centering
				\includegraphics[width=100mm]{golden_newton.png}
				\caption{Convergência do número de ouro pelo método de newton}
				\label{golden_newton}
			\end{figure}

			O método iterativo utilizado foi descrito pelo seguinte código:

			\begin{lstlisting}

			function [x, ex] = newton( f, df, x0, tol, nmax)
				f = inline(f);
				df = inline(df);
				x(1) = double(x0 - (f(x0)/df(x0)));
				ex(1) = abs(x(1)-x0);
				k = 2;
				while k <= nmax && ex(k-1) > tol
					 x(k) = double(double(x(k-1)) - double((f(x(k-1))/df(x(k-1)))));
					 ex(k) = abs(x(k)-x(k-1));
					 k = k+1;
				end
			end

			\end{lstlisting}

	\subsection{Pi($\pi$)}

		\subsubsection{Método Utilizando Funções Trigonométricas}

			Encontramos em um
			\href{http://mathforum.org/library/drmath/view/65244.html}{fórum de
			matemática} um método iterativo que calcula $ \pi $ de uma forma
			aparentemente mais simples, apesar de sua complexidade estar
			escondida na função \emph{sin}. O método está descrito a seguir:

			\begin{equation}
			\label{magic_equation}
				P(n+1) = P(n) + sin(P(n))
			\end{equation}

			$P(n)$ seria a aproximação de $\pi$ na iteração $n$. Esse método
			consegue convergir para $\pi$ com um número muito baixo de
			iterações.

			\input{./tables/pi-sin.tex}

			O seguinte gráfico foi gerado com a análise dos resultos:

			\begin{figure}[H]
				\centering
				\includegraphics[width=100mm]{pi_magic.png}
				\caption{Convergência do $\pi$}
				\label{fig:pi-magic}
			\end{figure}

			O método iterativo utilizado foi descrito pelo seguinte código:

			\begin{lstlisting}

			function [pif, pi_vec] = pi_it(iteration)
				pif(1) = 3 + sin(3);
				pi_vec(1) = pi
				for i = 2:iteration
					pif(i) = pif(i-1) + sin(pif(i-1));
					pi_vec(i) = pi;
					aux = pif(i);
				end
			end

			\end{lstlisting}

	\subsection{$e^x$}

		A função $e^x$ é um função exponencial cuja base é o número de Euler,
		também conhecida como função exponencial natural.

		Para o calculo da da função utilizamos a seguinte série de Taylor
		
		\begin{equation}
			\sum_{n=1}^{n} = \frac{x^n}{n!}
		\end{equation}

		Para exemplificar a foram realizadas 40 iteração para a seguinte função
		$e^5$, e obtivemos os seguintes resultaodos:

		\input{./tables/exponential.tex}

		Utilizando a série de Taylor foi percebido que o método converge após 24
		iterações.A complexidade deste método encontra-se no cáculo de
		\emph{n!}.  Podemos observar na Figura~\ref{eq:phi} a representação
		gráfica da convegência entre a série e $e^5$. 

		\begin{figure}[H] \centering
			\includegraphics[scale=.75]{ex5.png} 
		\caption{Convergência de $e^5$ em 40 iterações}
		\label{ex5} 
		\end{figure}

		Utilizamos o Algoritmo exponential implementado como mostrado a seguir,
		que retorna uma matriz de forma que cada coluna representa uma iteração
		e a primeira linha o valor calculado, a segunda o valor de $e^5$ e a
		tereceira linha é utilizada para guardar a diferença entre $e^5$ o valor
		calculado na iteração.

		\begin{lstlisting}
		function [ex] = exponential(x, iteration)
			ex2 = e^x;
			ex(1,1) = 1;
			ex(2,1) = ex2;
			ex(3,1) = ex2 - ex(1,1);
			for k=2:iteration
				ex(1,k) = ex(1,k-1) + (power(x,k-1) / factorial(k-1));
				ex(2,k) = ex2;
				ex(3,k) = ex2 - ex(1,k);
			end
		end
		\end{lstlisting}

	\subsection{Erdős-Borwein}

		A constante de Erdős-Borwein é a soma dos inversos multiplicativos dos
		números de Mersenne, e por definição é:

		\begin{equation}
			E = \displaystyle\sum_{n=1}^{\infty} \frac{1}{2^n-1} \approx 1.606695152415291763\dots
		\end{equation}

		Executando no \emph{octave}, obtemos os seguintes resultados:

		\input{./tables/erdos.tex}

		Podemos ver o número se estabilizando no seguinte gráfico,
		construído a partir dos resultados da tabela.

		\begin{figure}[H]
			\centering
			\includegraphics[width=100mm]{erdos.png}
			\caption{Convergência do erdős-borwein em 50 iterações}
			\label{erdos_graphic}
		\end{figure}

		A definição de $E$ foi codificada da seguinte maneira:

		\begin{lstlisting}

		function [er] = erdos(iteration)
			er(1) = 1;
			for i=2:iteration
				er(i) = er(i-1) + (1 / ((2^i)-1));
			end
		end

		\end{lstlisting}
