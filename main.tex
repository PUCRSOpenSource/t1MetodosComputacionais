\documentclass[a4paper]{article}
\usepackage{sbc-template}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{enumerate}
\usepackage{color}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{morefloats}

\graphicspath{{figures/}}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	language=matlab,
	tabsize=3
}

\sloppy

%
%Explicação do método de ponto fixo pelo Batista
%
%Um método iterativo simples consiste em resolver uma equação do tipo $x =
%\phi(x)$, aplicando sucessivamente a função $\phi$. De modo que, se a sequência
%$x_{n+1} = \phi(x_{n})$ for convergente, converge para uma solução da equação.

\author{Daniel De Luca, Diego Jornada, Matthias Nunes}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio Grande do Sul\\
  (PUCRS)
  \email{\{daniel.luca, diego.jornada, matthias.nunes\}@acad.pucrs.br}
}

\title{Métodos Computacionais \\ Trabalho I}

\begin{document}

\maketitle

\begin{resumo}

Este artigo descreve uma síntese sobre computação científica e alguns métodos
iterativos, quando utilizados para achar números irracionais.

\end{resumo}

\section{Introdução}

Computação científica é a área que estuda a construção de modelos matemáticos e
técnicas para análises quantitativas para resolver problemas cinetíficos e de
engenharia. Na prática, é a aplicação de simulações computacionais em análises
numéricas, ciência da computação teórica e outros problemas científicos de
disciplinas variadas.

No brasil, existem alguns institutos dedicados a computação científica, como por
exemplo o LNCC (Laboratório Nacional de Computação Científica) ou a SBMAC
(Sociedade Brasileira de Matemática Aplicada e Computacional). No mundo, os mais
conhecidos são: SCG (Symbolic Computation Group), NAG (Numerical Algorithms
Group), entre outros.

\section{Métodos Iterativos}

Um \textbf{método iterativo} é um procedimento matemático para resolução de
equações que gera uma sequência de aproximações, cada vez melhores, que servem
como solução para uma classe de problemas. Uma implementação específica de um
método iterativo, incluindo sua condição de parada, é um algoritmo. Um método
iterativo é considerado \textbf{convergente} se a sequência de valores geradas
converge para uma dada aproximação inicial.

Para uma definição mais teórica, o seguinte autor define:

\begin{quotation}

``Um método iterativo consiste em repetir uma determinada operação um certo número
de vezes até que nos seja fornecida uma aproximação, que satisfaça as condições
do problema e, para tal, a sequência de valores deve ser
convergente.''\cite{batista2014metodos}

\end{quotation}

Nos problemas do tipo encontre a raíz da equação, um método iterativo usa
uma suposição inicial para gerar sucessivas aproximações à uma solução. Em
Contraste, \textbf{métodos diretos} tentam resolver o problema em uma sequência
\emph{finita} de operações.

Um método iterativo é formado por quatro partes:~\cite{claudio2000calculo}
\begin{enumerate}[a)]
	\item Estimativa inicial: uma ou mais aproximações para a raiz desejada.
    \item Atualização: uma fórmula que atualize a solução aproximada.
    \item Critério de parada: uma forma de estabelecer quando parar o processo iterativo em qualquer caso.
    \item Estimador de exatidão: está associado ao critério de parada e provê uma estimativa do erro cometido.
\end{enumerate}

\newpage

\section{Exercícios}
%PI = http://mathforum.org/library/drmath/view/65244.html
Nessa seção vamos encontrar números irracionais conhecidos utilizando métodos iterativos.

\subsection{Número de Ouro}

	O número de ouro, também conhecido como $\phi$, é o resultado da seguinte
	equação: $x^2-x-1$,existem algums algoritmos para realizar a aproximação
	neste artigo duas destas formas serão abordadas, a primeira utilizando
	frações continuas e o seguundo calculando as raizaes da equação utiizando
	método de newton.

\subsubsection{Frações Continuadas}

	Frações conitinuadas são formas de representar números reais de tal forma
	que a expressão básica tem o seguinte formato:
	\begin{equation}\label{eq:phi}
		a_0 + \frac{b_0}{a_1 + \frac{b_1}{a_n + \dots}}
	\end{equation}

	Para calcular o $\phi$ devemos substituir \emph{a} e \emph{b} por 1. Na
	Fração~\ref{eq:phi}.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|c|}

		\hline
		Iteração & $x$ & Iteração & $x$ \\
		\hline
		1 & 2.00000000000000000000 & 26 & 1.61803398873830306393 \\
		\hline
		2 & 1.50000000000000000000 & 27 & 1.61803398875432247195 \\
		\hline
		3 & 1.66666666666666651864 & 28 & 1.61803398874820381081 \\
		\hline
		4 & 1.60000000000000008882 & 29 & 1.61803398875054060824 \\
		\hline
		5 & 1.62500000000000000000 & 30 & 1.61803398874964821097 \\
		\hline
		6 & 1.61538461538461541878 & 31 & 1.61803398874998904944 \\
		\hline
		7 & 1.61904761904761906877 & 32 & 1.61803398874985893130 \\
		\hline
		8 & 1.61764705882352943789 & 33 & 1.61803398874990866929 \\
		\hline
		9 & 1.61818181818181816567 & 34 & 1.61803398874988957346 \\
		\hline
		10 & 1.61797752808988759554 & 35 & 1.61803398874989690093 \\
		\hline
		11 & 1.61805555555555558023 & 36 & 1.61803398874989401435 \\
		\hline
		12 & 1.61802575107296142676 & 37 & 1.61803398874989512457 \\
		\hline
		13 & 1.61803713527851456000 & 38 & 1.61803398874989490253 \\
		\hline
		14 & 1.61803278688524576623 & 39 & 1.61803398874989490253 \\
		\hline
		15 & 1.61803444782168193150 & 40 & 1.61803398874989490253 \\
		\hline
		16 & 1.61803381340012508716 & 41 & 1.61803398874989490253 \\
		\hline
		17 & 1.61803405572755432118 & 42 & 1.61803398874989490253 \\
		\hline
		18 & 1.61803396316670644595 & 43 & 1.61803398874989490253 \\
		\hline
		19 & 1.61803399852180351814 & 44 & 1.61803398874989490253 \\
		\hline
		20 & 1.61803398501735795634 & 45 & 1.61803398874989490253 \\
		\hline
		21 & 1.61803399017559712547 & 46 & 1.61803398874989490253 \\
		\hline
		22 & 1.61803398820532517988 & 47 & 1.61803398874989490253 \\
		\hline
		23 & 1.61803398895790184753 & 48 & 1.61803398874989490253 \\
		\hline
		24 & 1.61803398867044334608 & 49 & 1.61803398874989490253 \\
		\hline
		25 & 1.61803398878024262686 & 50 & 1.61803398874989490253 \\
		\hline

	\end{tabular}
	\label{golden_fraction}
	\caption{Convergência do número de ouro pelo método de frações continuadas}
\end{table}

Como fica ilustrado na tabela, o número já se estabiliza antes mesmo de
chegarmos à 50 iterações.

\begin{figure}[H]
    \centering
    \includegraphics[width=100mm]{golden_frac.png}
    \caption{Convergência do número de ouro pelo método de frações continuadas}
    \label{golden_frac}
\end{figure}


O método iterativo utilizado foi descrito pelo seguinte código:

\begin{lstlisting}

function [x] =  phi_frac(iteration=1)
	aux = 1;
	for i= 1:iteration
		aux = double(1 + 1/aux);
		x(i) = aux;
	end
end

\end{lstlisting}

\subsubsection{Método de Newton}

A ideia do método de Newton é a partir de um valor inicial arbitrário, então a
função é aproximada por sua reta tangente. O $x$ que intercepta a reta e a
função é computado, e ele será uma melhor aproximação que o chute inicial. O
método, então, pode ser iterado.

Analizando novamente o número de ouro, mas com o método de newton, um número
muito menor de iterações é observado.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		Iteração & $x$ & erro \\
		\hline
		1 & 1.66666666666666674068 & 0.33333333333333325932 \\
		\hline
		2 & 1.61904761904761906877 & 0.04761904761904767192 \\
		\hline
		3 & 1.61803444782168193150 & 0.00101317122593713727 \\
		\hline
		4 & 1.61803398874998904944 & 0.00000045907169288206 \\
		\hline
		5 & 1.61803398874989490253 & 0.00000000000009414691 \\
		\hline
		6 & 1.61803398874989490253 & 0.00000000000000000000 \\
		\hline
	 \end{tabular}
	\label{golden_newton}
	\caption{Convergência do número de ouro pelo método de newton}
\end{table}

Isso pode ser observado no gráfico abaixo.

\begin{figure}[H]
    \centering
    \includegraphics[width=100mm]{golden_newton.png}
    \caption{Convergência do número de ouro pelo método de newton}
    \label{golden_newton}
\end{figure}

O método iterativo utilizado foi descrito pelo seguinte código:

\begin{lstlisting}

function [x, ex] = newton( f, df, x0, tol, nmax)
	f = inline(f);
	df = inline(df);
	x(1) = double(x0 - (f(x0)/df(x0)));
	ex(1) = abs(x(1)-x0);
	k = 2;
	while k <= nmax && ex(k-1) > tol
		 x(k) = double(double(x(k-1)) - double((f(x(k-1))/df(x(k-1)))));
		 ex(k) = abs(x(k)-x(k-1));
		 k = k+1;
	end
end

\end{lstlisting}

\subsection{Pi($\pi$)}

\subsubsection{Método Misterioso}

Encontramos em um
\href{http://mathforum.org/library/drmath/view/65244.html}{fórum de matemática}
um método iterativo que calcula $\pi$ de uma forma aparentemente mais simples,
apesar de sua complexidade estar escondida na função $sin$. O método está
descrito a seguir:

\begin{equation}
P(n+1) = P(n) + sin(P(n))
\end{equation}

$P(n)$ seria a aproximação de $\pi$ na iteração $n$. Esse método consegue
convergir para $\pi$ com um número muito baixo de iterações.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|}
    	\hline
		$P(n)$ \\
		\hline
		3.14112000805986735230135309393517673015594482421875 \\
		\hline
		3.14159265357219563696844488731585443019866943359375 \\
		\hline
		3.14159265358979311599796346854418516159057617187500 \\
		\hline
		3.14159265358979311599796346854418516159057617187500 \\
		\hline
		3.14159265358979311599796346854418516159057617187500 \\
		\hline
		\hline
		$\pi$ \\
		\hline
		3.14159265358979311599796346854418516159057617187500 \\
		\hline
		\hline
		$P(n) - \pi$  Para visualizar a diferença \\
		\hline
		-4.72645529925763696610374609008431434631347656250000 \\
		\hline
		-1.75974790295185812283307313919067382812500000000000 \\
		\hline
		0.00000000000000000000000000000000000000000000000000 \\
		\hline
		0.00000000000000000000000000000000000000000000000000 \\
		\hline
		0.00000000000000000000000000000000000000000000000000 \\
		\hline
	\end{tabular}
	\label{pi_magic}
	\caption{Convergência do $\pi$}
\end{table}

O seguinte gráfico foi gerado com a análise dos resultos:

\begin{figure}[H]
    \centering
    \includegraphics[width=100mm]{pi_magic.png}
    \caption{Convergência do $\pi$}
    \label{pi_magic}
\end{figure}

O método iterativo utilizado foi descrito pelo seguinte código:

\begin{lstlisting}

function [pif, pi_vec] = pi_it(iteration)
	pif(1) = 3 + sin(3);
	pi_vec(1) = pi
	for i = 2:iteration
		pif(i) = pif(i-1) + sin(pif(i-1));
		pi_vec(i) = pi;
		aux = pif(i);
	end
end

\end{lstlisting}

\subsection{Erdős-Borwein}

A constante de Erdős-Borwein é a soma dos inversos multiplicativos dos números
de Mersenne, e por definição é:

\begin{equation}
	E = \displaystyle\sum_{n=1}^{\infty} \frac{1}{2^n-1} \approx 1.606695152415291763\dots
\end{equation}

Executando no \emph{octave}, obtemos os seguintes resultados:

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|c|}
    	\hline
		Iteração & $E$ & Iteração & $E$ \\
    	\hline
		1 & 1.0000000000 & 19 & 1.6066932451 \\
    	\hline
		2 & 1.3333333333 & 20 & 1.6066941987 \\
    	\hline
		3 & 1.4761904762 & 21 & 1.6066946756 \\
    	\hline
		4 & 1.5428571429 & 22 & 1.6066949140 \\
    	\hline
		5 & 1.5751152074 & 23 & 1.6066950332 \\
    	\hline
		6 & 1.5909882232 & 24 & 1.6066950928 \\
    	\hline
		7 & 1.5988622390 & 25 & 1.6066951226 \\
    	\hline
		8 & 1.6027838076 & 26 & 1.6066951375 \\
    	\hline
		9 & 1.6047407548 & 27 & 1.6066951450 \\
    	\hline
		10 & 1.6057182719 & 28 & 1.6066951487 \\
    	\hline
		11 & 1.6062067917 & 29 & 1.6066951506 \\
    	\hline
		12 & 1.6064509919 & 30 & 1.6066951515 \\
    	\hline
		13 & 1.6065730771 & 31 & 1.6066951519 \\
    	\hline
		14 & 1.6066341160 & 32 & 1.6066951522 \\
    	\hline
		15 & 1.6066646345 & 33 & 1.6066951523 \\
    	\hline
		16 & 1.6066798935 & 34 & 1.6066951524 \\
    	\hline
		17 & 1.6066875230 & 35 & 1.6066951524 \\
    	\hline
		18 & 1.6066913377 & 36 & 1.6066951524 \\
    	\hline
	\end{tabular}
	\label{erdos_table}
	\caption{Convergência do $E$}
\end{table}

Podemos ver o número se estabilizando no seguinte gráfico, construído a partir
dos resultados da tabela.

\begin{figure}[H]
    \centering
    \includegraphics[width=100mm]{erdos.png}
    \caption{Convergência do erdős-borwein em 50 iterações}
	\label{erdos_graphic}
\end{figure}

A definição de $E$ foi codificada da seguinte maneira:

\begin{lstlisting}

function [er] = erdos(iteration)
	er(1) = 1;
	for i=2:iteration
		er(i) = er(i-1) + (1 / ((2^i)-1));
	end
end

\end{lstlisting}

%\nocite{*}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
